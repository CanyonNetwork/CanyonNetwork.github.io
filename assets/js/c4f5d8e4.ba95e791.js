(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{78:function(e,a,t){"use strict";t.r(a),t.d(a,"default",(function(){return f}));var n=t(3),r=t(0),i=t.n(r),o=t(84),s=t(91),l=t(86),c=t(16),d=t(88),u=t(79),m=t.n(u),h=[{title:"Super Light Storage Consensus",imageUrl:"img/undraw_docusaurus_tree.svg",description:i.a.createElement(i.a.Fragment,null,"It's nonsense to provide the storage service in a hard way as the cost for building and running such an system will eventually imposed on the clients, rendering a truely low storage cost impossible in the long term. Canyon adopts the incentive-driven Proof of Access consensus initially deployed by Arweave, but on top of PoS instead of PoW, encouraging the validators to earn more rewards by storing more data, no sophisticated and hardware-demanding ZK proof, no need for particular TEE hardware.")},{title:"High Data Durability",imageUrl:"img/undraw_docusaurus_mountain.svg",description:i.a.createElement(i.a.Fragment,null,"One substantial advantage of combining PoS with PoA is able to guarantee a high data durability in theory. 12 nices (99.9999999999%) durability can be achieved with 200 validators and each of them stores at least 10% of the entire network storage, in a permanent way.")},{title:"Retrieval-driven Data Redundancy",imageUrl:"img/undraw_docusaurus_react.svg",description:i.a.createElement(i.a.Fragment,null,"It's unsound to require the storage miners to provide the retrieval services for free because the bandwidth is definitely not zero cost and valuable in fact. In Canyon, client needs to pay for the data retrieval, which in return adpatively incentives the data copies for these data with a frequent read need as validators can earn some extra retrieval fee aside from the basic storage reward.")},{title:"Forkless Upgrade and On-chain Governance",imageUrl:"img/undraw_docusaurus_mountain.svg",description:i.a.createElement(i.a.Fragment,null,"Implemented using Substrate framework which is the same framework that Polkadot is built on, making easier interoperability with Polkadot in the future. The forkless runtime upgrade feature ensures the chain is capable of iterating fastly.")}];function g(e){var a=e.imageUrl,t=e.title,n=e.description,r=Object(d.a)(a);return i.a.createElement("div",{className:Object(o.a)("col col--6",m.a.feature)},r&&i.a.createElement("div",{className:"text--center"},i.a.createElement("img",{className:m.a.featureImage,src:r,alt:t})),i.a.createElement("h3",null,t),i.a.createElement("p",null,n))}function f(){var e=Object(c.default)().siteConfig,a=void 0===e?{}:e;return i.a.createElement(s.a,{title:"Hello from "+a.title,description:"Description will go into a meta tag in <head />"},i.a.createElement("header",{className:Object(o.a)("hero hero--primary",m.a.heroBanner)},i.a.createElement("div",{className:"container"},i.a.createElement("h1",{className:"hero__title"},a.title),i.a.createElement("p",{className:"hero__subtitle"},a.tagline),i.a.createElement("div",{className:m.a.buttons},i.a.createElement(l.a,{className:Object(o.a)("button button--outline button--secondary button--lg",m.a.getStarted),to:Object(d.a)("docs/")},"Get Started")))),i.a.createElement("main",null,h&&h.length>0&&i.a.createElement("section",{className:m.a.features},i.a.createElement("div",{className:"container"},i.a.createElement("div",{className:"row"},h.map((function(e,a){return i.a.createElement(g,Object(n.a)({key:a},e))})))))))}}}]);